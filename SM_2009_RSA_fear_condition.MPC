\\\<?xml version="1.0" encoding="utf-8" standalone="yes"?>
\\\<?xml-stylesheet type="text/xsl" href="comments.xsl"?>
\\\
\\\<program>
\\\<title>Fear Conditioning Paradigm Code - Antonio Paolini&quot;s 2008 third-year research group</title>
\\\<history>
\\\ <revision number="1.0">
\\\  <author>Simeon Morgan &lt;smorgan@students.latrobe.edu.au&gt;</author>
\\\  <created>2008-07-02 14:09</created>
\\\  <summary>First version</summary>
\\\ </revision>
\\\</history>

Y2KCOMPLIANT \\\Force use of 4-digit year


\\\<constant group="general" represents="parameter" name="Def_MaxBlocksAcoustic" summary="Default maximum number of blocks to be recorded/processed for acoustic stim"></constant>
^Def_MaxBlocksAcoustic = 12
\\\<constant group="general" represents="parameter" name="Def_MaxBlocksElectric" summary="Default maximum number of blocks to be recorded/processed for electrical stim"></constant>
^Def_MaxBlocksElectric = 4
\\\<constant group="general" represents="parameter" name="Def_TrialDuration" summary="Duration of a single trial in sec"></constant>
^Def_TrialDuration = 10
\\\<constant group="general" represents="parameter" name="Abs_MaxTrials" summary="Limit on maximum number of trials to be recorded/processed"></constant>
^Abs_MaxTrials = 10000
\\\<constant group="general" represents="parameter" name="Def_MinITI" summary="Default minimum Inter-trial interval (in sec)"></constant>
^Def_MinITI = 90
\\\<constant group="general" represents="parameter" name="Def_MaxITI" summary="Default maximum Inter-trial interval (in sec)"></constant>
^Def_MaxITI = 120
\\\<constant group="general" represents="parameter" name="Def_ShocksOn" summary="Whether to deliver shocks (1=on, 0=off)"></constant>
^Def_ShocksOn = 1
\\\<constant group="general" represents="parameter" name="Def_TrialsType" summary="Default trials type (0=acoustic, 1=electrical, 2=random)"></constant>
^Def_TrialsType = 0

\\\<array name="G" outputName="Configuration" summary="">
DIM G = 20
\\\<column name="G_MaxBlocks" outputName="Max Blocks" summary="Number of blocks before automatic termination"></column>
^G_MaxBlocks = 0
\\\<column name="G_ShocksOn" outputName="Shocks on" summary="Whether to deliver shocks"></column>
^G_ShocksOn = 1
\\\<column name="G_TrialsType" outputName="Trials type" summary="Type of trials to present (0=acoustic, 1=electrical, 2=random)"></column>
^G_TrialsType = 2
\\\<column name="G_ShockDurationMsec" outputName="Shock duration" summary="Duration (in ms) of foot-shock entered at configuration time -&gt; then copied to ^G_ShockDurationSec for actual use"></column>
^G_ShockDurationMsec = 3
\\\<column name="G_ShockDurationSec" summary="Duration (in s) of foot-shock"></column>
^G_ShockDurationSec = 4
\\\<column name="G_ToneDurationSec" outputName="Tone duration" summary="Duration of tone presentation in seconds"></column>
^G_ToneDurationSec = 5
\\\<column name="G_TrialDurationSec" outputName="Trial duration" summary="Duration of trial in seconds"></column>
^G_TrialDurationSec = 6
\\\<column name="G_MinITI" outputName="Min ITI" summary="Minimum inter-trial interval (in sec)"></column>
^G_MinITI = 7
\\\<column name="G_MaxITI" outputName="Max ITI" summary="Maximum inter-trial interval (in sec)"></column>
^G_MaxITI = 8
\\\<column name="G_TrialDuration" summary="Duration of trial (in ticks - autogenerated)"></column>
^G_TrialDuration = 9
\\\<column name="G_ToneShockDelay" summary="Pause (in sec) between onset of tone and onset of shock. Auto-calculated."></column>
^G_ToneShockDelay = 10
\\\<column name="G_ShockDuration" summary="Duration (in ticks) of foot-shock - autogenerated"></column>
^G_ShockDuration = 11
\\\<column name="G_CamUnconnectedState" summary="Used to store 'Unconnected' StateID of camera"></column>
^G_CamUnconnectedState = 12
\\\<column name="G_CamConnectOkState" summary="Used to store 'Ok' StateID of camera"></column>
^G_CamConnectOkState = 13
\\\<column name="G_CamConnectFailState" summary="Used to store 'Fail' StateID of camera"></column>
^G_CamConnectFailState = 14
\\\<column name="G_UltrasonicIndexOffset" summary="Array offset for ultrasonic time recording"></column>
^G_UltrasonicIndexOffset = 15
\\\<column name="G_USSequentialReadingA" summary="Number of sequential ultrasonic detections A"></column>
^G_USSequentialReadingsA = 16
\\\<column name="G_USEventIndexA" summary="Index of current event for ultrasonic A"></column>
^G_USEventIndexA = 17
\\\<column name="G_USSequentialReadingB" summary="Number of sequential ultrasonic detections B"></column>
^G_USSequentialReadingsB = 18
\\\<column name="G_USEventIndexB" summary="Index of current event for ultrasonic B"></column>
^G_USEventIndexB = 19
\\\</array>

\\\<enum name="G_ShocksOn" summary="Identifiers for shocks on or off">
\\\\<option value="0" name="^G_ShocksOn_Off" summary="Shocks turned off"></option>
^G_ShocksOn_Off = 0
\\\\<option value="0" name="^G_ShocksOn_On" summary="Shocks turned on"></option>
^G_ShocksOn_On = 1
\\\</enum>


\\\Control Variables 
\\\<!--<variable alias="" name="" summary=""></variable>-->
\\\<variable alias="Maximum Trials" name="G(^G_MaxTrials)" summary="Number of trials before automatic termination"></variable>
Var_Alias Maximum Blocks (Maximum 100)	= G(0)
\\\<variable alias="Deliver shocks" name="G(^G_ShocksOn)" summary="Whether shocks will be delivered"></variable>
Var_Alias Deliver shocks (1=yes 0=no)	= G(1)
\\\<variable alias="Trial type" name="G(^G_TrialsType)" summary="Type of trials (0=acoustic, 1=electrical, 2=random)">"></variable>
Var_Alias Trial type (0=acoustic 1=electrical 2=random)	= G(2)
\\\<variable alias="Shock Duration (msec)" name="G(^G_ShockDurationMsec)" summary="Duration (in msec) of foot-shock for configuration only"></variable>
Var_Alias Shock Duration (msec)				= G(3)
\\\<variable alias="Tone Duration" name="G(^G_ToneDurationSec)" summary="Duration (in seconds) of presented tone stimulus"></variable>
Var_Alias Tone Duration (sec)				= G(5)
\\\<variable alias="Minimum Inter-trial Interval (sec)" name="G(^G_MinITI)" summary="Minimum inter-trial interval (in sec)"></variable>
Var_Alias Minimum Inter-trial Interval		= G(7)
\\\<variable alias="Maximum Inter-trial Interval (sec)" name="G(^G_MaxITI)" summary="Maximum inter-trial interval (in sec)"></variable>
Var_Alias Maximum Inter-trial Interval		= G(8)


\\\Example comment line <!--<constant represents="input|output|other" name="LeverTrigger" summary="Input ID of the fixed lever 'starting' trigger"></constant>-->

\\\Constant block
\\\<input name="Inp_HeadEntry" summary="Input ID of the head entry unit on pellet dispenser"></input>
^Inp_HeadEntry = 1
\\\<input name="Inp_Lickometer" summary="Input ID of the lickometer"></input>
^Inp_Lickometer = 2
\\\<input name="Inp_LeverTrigger" summary="Input ID of the fixed lever 'starting' trigger"></input>
^Inp_LeverTrigger = 3
\\\<input name="Inp_LeverInputLeft" summary="Input ID of retractable lever on the left"></input>
^Inp_LeverInputLeft = 4
\\\<input name="Inp_LeverInputRight" summary="Input ID of retractable lever on the right"></input>
^Inp_LeverInputRight = 5
\\\<input name="Inp_UltrasonicA" summary="Input ID of ultrasonic input 1 of 2"></input>
^Inp_UltrasonicA = 6
\\\<input name="Inp_UltrasonicB" summary="Input ID of ultrasonic input 2 of 2"></input>
^Inp_UltrasonicB = 7

\\\<output name="Out_SnackDispenser" summary="Output ID of feeder unit."><use>Dispenses on OFF->ON transition</use></output>
^Out_SnackDispenser = 1
\\\<output name="Out_BeverageDispenser" summary="Output ID of drinking unit."><use>Toggle liquid availability: OFF->Unavailable, ON->Available</use></output>
^Out_BeverageDispenser = 2
\\\<output name="Out_LeftLeverRetract" summary="Output trigger to extend/retract left lever"><use>Toggle extended state of lever; OFF->Not extended, ON->Extended</use></output>
^Out_LeftLeverRetract = 3
\\\<output name="Out_RightLeverRetract" summary="Output trigger to extend/retract right lever"><use>Toggle extended state of lever; OFF->Not extended, ON->Extended</use></output>
^Out_RightLeverRetract = 4
\\\<output name="Out_LickShockSwitch" summary="Output ID of ENV-250A Contact Lickometer switching unit."><use>OFF->Lickometer active, ON->Floor connected to shock emitter</use></output>
^Out_LickShockSwitch = 5
\\\<output name="Out_Ultrasonic" summary="Output ID of ultrasonic recording unit."><use>???</use></output>
^Out_Ultrasonic = 6
\\\<output name="Out_ShockEmitter" summary="Output ID of shock unit."><use>Toggle shock delivery: OFF->No shock presently being delivered, ON->CONTINUOUS SHOCK PRESENTLY BEING DELIVERED</use></output>
^Out_ShockEmitter = 7
\\\<output name="Out_HouseLightRear" summary="Output ID of rear-most house light."><use>OFF->unlit, ON->lit</use></output>
^Out_HouseLightRear = 9
\\\<output name="Out_HouseLightMid" summary="Output ID of miidle house light."><use>OFF->unlit, ON->lit</use></output>
^Out_HouseLightMid = 10
\\\<output name="Out_HouseLightFront" summary="Output ID of front-most house light."><use>OFF->unlit, ON->lit</use></output>
^Out_HouseLightFront = 11
\\\<output name="Out_LedRed" summary="Output ID of Red LED (rearmost)."><use>OFF->unlit, ON->lit</use></output>
^Out_LedRed = 12
\\\<output name="Out_LedGreen" summary="Output ID of Green LED (frontmost)."><use>OFF->unlit, ON->lit</use></output>
^Out_LedGreen = 13
\\\<output name="Out_LedYellow" summary="Output ID of Yellow LED (middle)."><use>OFF->unlit, ON->lit</use></output>
^Out_LedYellow = 14
\\\<output name="Out_Fan" summary="Output ID of venting fan."><use>OFF->fan off, ON->fan on</use></output>
^Out_Fan = 15
\\\<output name="Out_TDStim1" summary="Output ID to trigger presentation of stimulus 1."><use>OFF->No stim 1, ON->stim 1 playing</use></output>
^Out_TDStim1 = 8
\\\<output name="Out_TDStim2" summary="Output ID to trigger presentation of stimulus 2."><use>OFF->No stim 2, ON->stim 2 playing</use></output>
^Out_TDStim2 = 15
\\\<output name="Out_TDStimType" summary="Output ID to identify whether acoustic or electrical stim."><use>OFF->Acoustic stim, ON->Electrical stim</use></output>
^Out_TDShock = 16

\\\<constant group="audio" represents="parameter" name="Snd_ToneDuration" summary="Duration of presentation of tone stimulus (in ms)"></constant>
^Snd_ToneDuration = 250
\\\<constant group="audio" represents="parameter" name="Snd_RiseFallTime" summary="Rise/Fall time (in ms)"></constant>
^Snd_RiseFallTime = 10

\\\<constant group="shock" represents="parameter" name="Shk_ShockDuration" summary="Duration of the electrical shock co-terminating with tone (in ms)"></constant>
^Shk_ShockDuration = 500

\\\<constant group="k-pulse" represents="parameter" name="KP_ExperimentEnd" summary="Trigger the experiment to end"></constant>
^KP_ExperimentEnd = 1

\\\<constant group="z-pulse" represents="parameter" name="ZP_TrialStart" summary="Signals commencement of a trial"></constant>
^ZP_TrialStart = 1
\\\<constant group="z-pulse" represents="parameter" name="ZP_TrialEnd" summary="Signals end of a trial"></constant>
^ZP_TrialEnd = 2

\\\<constant group="z-pulse" represents="parameter" name="ZP_TerminateExperiment" summary="End the experiment - may be used if error occurrs"></constant>
^ZP_TerminateExperiment = 3
\\\<constant group="z-pulse" represents="parameter" name="ZP_ExperimentEnd" summary="Trigged to end the experiment"></constant>
^ZP_ExperimentEnd = 4

\\\<constant group="z-pulse" represents="parameter" name="ZP_ShockTrigger" summary="Trigger to send shock information to TD gear"></constant>
^ZP_ShockTrigger = 5

\\\<constant group="z-pulse" represents="parameter" name="ZP_StartVideoRec" summary="Start video recording"></constant>
^ZP_StartVideoRec = 6
\\\<constant group="z-pulse" represents="parameter" name="ZP_EndVideoRec" summary="End video recording"></constant>
^ZP_EndVideoRec = 7


\\\ARRAYS
\\\<array name="J" outputName="Trial summary" summary="Trial summary data">
DIM J = 8
\\\<column name="J_CompletedTrials" outputName="Completed trials" summary="Total number of trials that have occurred so far"></column>
^J_CompletedTrials = 0
\\\<column name="J_CompletedAcousticTrials" outputName="Completed acoustic trials" summary="Total number of acoustic trials that have occurred so far"></column>
^J_CompletedAcousticTrials = 1
\\\<column name="J_CompletedElectricalTrials" outputName="Completed electrical trials" summary="Total number of electrical trials that have occurred so far"></column>
^J_CompletedElectricalTrials = 2
\\\<column name="J_CompletedDiscrimTrials" outputName="Completed discriminating trials" summary="Total number of acoustic trials of an alternate frequency without shock that have occurred so far"></column>
^J_CompletedDiscrimTrials = 3
\\\<column name="J_MeanITI" outputName="Mean ITI" summary="Mean Inter-trial interval"></column>
^J_MeanITI = 4
\\\<column name="J_CurrentHours" outputName="Hours" summary="Hours since commencement (for H:M:S.MS)"></column>
^J_CurrentHours = 5
\\\<column name="J_CurrentMinutes" outputName="Minutes" summary="Minutes since commencement (for H:M:S.MS)"></column>
^J_CurrentMinutes = 6
\\\<column name="J_CurrentSeconds" outputName="Seconds" summary="Seconds since commencement (for H:M:S.MS)"></column>
^J_CurrentSeconds = 7
\\\<column name="J_CurrentMilliseconds" outputName="Milliseconds" summary="Milliseconds since commencement (for H:M:S.MS) "></column>
^J_CurrentMilliseconds = 8
\\\</array>

\\\<array name="K" outputName="Trials" summary="Specific trial data">
DIM K = 90000 \ we wish it could be (^Gen_MaxTrials * 6) - 1
\\\<column name="K_TrialNumber" outputName="Trial number" summary="Number of this trial"></column>
^K_TrialNumber = 0
\\\<column name="K_TrialTimeHour" outputName="Hour" summary="Time post-commencement (H) this trial occurred"></column>
^K_TrialTimeHour = 1
\\\<column name="K_TrialTimeMinute" outputName="Minute" summary="Time post-commencement (M) this trial occurred"></column>
^K_TrialTimeMinute = 2
\\\<column name="K_TrialTimeSecond" outputName="Second" summary="Time post-commencement (S) this trial occurred"></column>
^K_TrialTimeSecond = 3
\\\<column name="K_TrialTimeMillisecond" outputName="Millisecond" summary="Time post-commencement (MS) this trial occurred"></column>
^K_TrialTimeMillisecond = 4
\\\<column name="K_TrialMsec" outputName="Msec from start" summary="Time post-commencement (msec) this trial occurred TOTAL - Not related to H:M:S"></column>
^K_TrialMsec = 5
\\\<column name="K_PreITI" outputName="Pre-trial interval" summary="Interval prior to this trial"></column>
^K_PreITI = 6
\\\<column name="K_TrialType" outputName="Trial type" summary="0=acoustic trial, 1=electrical trial, 2=discriminant acoustic trial without shock"></column>
^K_TrialType = 7
\\\<column name="K_Shock" outputName="Shocked" summary="0=no shock occurred, 1=shock occurred"></column>
^K_Shock = 8
\\\</array>
\\\<constant group="general" represents="parameter" name="K_TrialIndexMultiplier" summary="Multiplier to be used for each trial"></constant>
^K_TrialIndexMultiplier = 9

\\\<array name="F" summary="Interval offset multipliers">
LIST F = 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
	 101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120
\\\<column name="F_IntervalOffset" summary="An integer 0-120 to multiply by the (MaxITI - MinITI) and divided by 120 to get the 'inter-trial interval'" />
^F_IntervalOffset = 1 \\\this is actually never used, because there is only one column; included for completeness
\\\</array>
\\\<constant group="general" represents="parameter" name="F_TotalOffsets" summary="Divisor to be used when using the offsets from array F (= max value of array of F, so after division falls into range 0-1 inclusive)"></constant>
^F_TotalOffsets = 120

\\\<array name="I" summary="Integer list representing electrical vs acoustic stimulation">
LIST I = 0,1
\\\<column name="I_TrialType" summary="Trial type - 0=acoustic, 1=electrical, 2=discriminant acoustic"></column>
\\\</array>

\\\<enum name="I_TrialType" summary="Identifiers for trial types">
\\\\<option value="0" name="^I_TrialType_Acoustic" summary="Acoustic trial"></option>
^I_TrialType_Acoustic = 0
\\\\<option value="1" name="^I_TrialType_Electrical" summary="Electrical trial"></option>
^I_TrialType_Electrical = 1
\\\</enum>


\\\\<array name="H" summary="Ultrasonic signal data">
DIM H = 60000 
\\\<column name="H_StartHour" summary="Hour of this event starting"></column>
\^H_StartHour = 0
\\\<column name="H_StartMinute" summary="Minute of this event starting"></column>
\^H_StartMinute = 1
\\\<column name="H_StartSecond" summary="Second of this event starting"></column>
\^H_StartSecond = 2
\\\<column name="H_StartMillisecond" summary="Millisecond of this event starting"></column>
\^H_StartMillisecond = 3
\\\<column name="H_StartMsec" summary="Absolute milliseconds of this event starting"></column>
\^H_StartMsec = 4
\\\<column name="H_EndHour" summary="Hour of this event ending"></column>
\^H_EndHour = 5
\\\<column name="H_EndMinute" summary="Minute of this event ending"></column>
\^H_EndMinute = 6
\\\<column name="H_EndSecond" summary="Second of this event ending"></column>
\^H_EndSecond = 7
\\\<column name="H_EndMillisecond" summary="Millisecond of this event ending"></column>
\^H_EndMillisecond = 8
\\\<column name="H_EndMsec" summary="Absolute milliseconds of this event ending"></column>
\^H_EndMsec = 9
\\\<column name="H_Band" summary="Which band led to the trigger"></column>
\^H_Band = 10
\\\</array>
\\\<constant group="general" represents="parameter" name="H_IndexMultiplier" summary="Multiplier to be used for each signal"></constant>
^H_IndexMultiplier = 11

\\\Variable declarations
\\\<!--<variable name="" summary=""></variable>-->
\\\<variable name="L" summary="Trial type"></variable>
\\\<variable name="P" summary="Storage variable for camera state"></variable>
\\\<variable name="Q" summary="Current offset for B array"></variable>
\\\<variable name="R" summary="Inter-trial pause in ticks (generated)"></variable>
\\\<variable name="S" summary="Inter-trial pause in seconds (generated)"></variable>
\\\<variable name="X" summary="Inter-trial countdown in seconds (generated)"></variable>
\\\<variable name="V" summary="Temporary store for shuffling data to sound processor"></variable>

\\\<variable name="T" summary="Timer - # of msec since commencement"></variable>
\\\<variable name="U" summary="Timer - variable swapping 1"></variable>
\\\<variable name="W" summary="Timer - variable swapping 2"></variable>


\\\<stateset id="1" summary="Run the preparation and termination functions of the program">
S.S.1,
\\\<state id="1" summary="Set variables to default values">
S1,
	0":;
\\\		SET G(^G_MaxBlocks) = ^Def_MaxBlocks;
		SET G(^G_ShockDurationMsec) = ^Shk_ShockDuration;
		SET G(^G_ToneDurationSec) = (^Snd_ToneDuration / 1000);
		SET G(^G_MinITI) = ^Def_MinITI;
		SET G(^G_MaxITI) = ^Def_MaxITI;

		SET G(^G_ShocksOn) = ^Def_ShocksOn;
		SET G(^G_TrialsType) = ^Def_TrialsType;


		SET H(0) = -987.987;
		SET K(0) = -987.987;

		---> S5
\\\</state>
\\\<state id="5" summary="Pause until start command is issued; then convert used-data from ms to sec where required and continue. Presumably variables are set when start is triggered.">
S5,
	#START:;
		SHOW 5, Running, 0;
		SET G(^G_ShockDurationSec) = (G(^G_ShockDurationMsec) / 1000);
		SET G(^G_ShockDuration) = (G(^G_ShockDurationSec) * 1");
		SET G(^G_TrialDuration) = (G(^G_TrialDurationSec) * 1");
		SET G(^G_ToneShockDelay) = (G(^G_TrialDurationSec) - G(^G_ShockDurationSec)) * 1";

		\initialise sound unit
		~InitANL926;~;
		SET V = G(^G_ToneSPL);
		~SetAmp(MG, BOX, V);~;
		SET V = ^Snd_RiseFallTime;
		~SetRF(MG, BOX, V);~;
		SET V = G(^G_ToneDurationSec) * 1000;
		~SetDur(MG, BOX, V);~;
		SET V = G(^G_ToneFrequency);
		~SetFreq(MG, BOX, V);~;

		ON ^Out_HouseLightRear;

		Z^ZP_StartVideoRec;
		ON ^Out_LickShockSwitch;
		ON ^Out_Ultrasonic;
		---> S10
	0.01":;
		SET G(^G_ShockDurationSec) = (G(^G_ShockDurationMsec) / 1000);

		SHOW 5, Awaiting Start, 0;
		SHOW 1, Max Blocks, G(^G_MaxBlocks);
		SHOW 11, Shock Duration (s), G(^G_ShockDurationSec);
		SHOW 12, Tone Duration (s), G(^G_ToneDurationSec);
		SHOW 21, Minimum ITI (s), G(^G_MinITI);
		SHOW 22, Max ITI (s), G(^G_MaxITI);

		IF G(^G_TrialsType) = ^I_TrialType_Acoustic [@acoustic trial, @not acoustic trial]
			@acoustic trials:;
				SET G(^G_MaxBlocks) = ^Def_MaxBlocksAcoustic;
			@not acoustic  trials:;
				SET G(^G_MaxBlocks) = ^Def_MaxBlocksElectric;
			---> SX
\\\</state>

\\\<state id="10" summary="Wait for program termination">
S10,
	#Z^ZP_TerminateExperiment:;
		OFF ^Out_Ultrasonic;
		OFF ^Out_HouseLightRear;
		LOCKOFF ^Out_ShockEmitter;
		OFF ^Out_LickShockSwitch;
		~ToneOff(MG, BOX);~;
		SET H(G(^G_UltrasonicIndexOffset)) = -987.987;
		SET K(Q + ^K_TrialIndexMultiplier) = -987.987;
		---> S20

\\\</state>
\\\<state id="10" summary="Turn off all outputs, save data and end">
S20,   
  0":;
	CLEAR 5,5;
	SHOW 4, Experiment Complete, 1;
  	---> STOPABORTFLUSH
\\\</state>
\\\</stateset>


\\\<stateset id="2" summary="Operate the experiment functionally">
S.S.2,
\\\<state id="1" summary="Wait for the start trigger">
S1,
	#START:;
		---> S2
\\\</state>
\\\<state id="2" summary="Generate randomly-determined Inter-Trial Pause, and update trial data">
S2,
  0":;
	SET Q = J(^J_CompletedTrials) * ^K_TrialIndexMultiplier;
	SET K(Q + ^K_TrialIndexMultiplier) = -987.987;
	RANDI S = F;
	SET S = S * (G(^G_MaxITI) - G(^G_MinITI)) / ^F_TotalOffsets;
	SET S = G(^G_MinITI) - G(^G_TrialDurationSec) + S;
	SHOW 4, Inter-trial delay, S;
	SET R = S * 1";

	SET K(Q + ^K_TrialNumber) = J(^J_CompletedTrials);
	SET K(Q + ^K_TrialTimeHour) = J(^J_CurrentHours), K(Q + ^K_TrialTimeMinute) = J(^J_CurrentMinutes), K(Q + ^K_TrialTimeSecond) = J(^J_CurrentSeconds), K(Q + ^K_TrialTimeMillisecond) = J(^J_CurrentMilliseconds);
	SET K(Q + ^K_TrialMsec) = T;
	SET K(Q + ^K_TrialNumber) = J(^J_CompletedTrials);
	SET K(Q + ^K_ToneSPL) = G(^G_ToneSPL);
	SET K(Q + ^K_PreITI) = S;
	SET K(Q + ^K_TrialIndexMultiplier) = -987.987;
	Z^ZP_TrialStart;
	RANDD L = I;
	IF (G(^G_TrialsType) = ^I_TrialType_Acoustic) OR ((L = ^I_TrialType_Acoustic) AND (G(^G_TrialsType) = 2)) [@acoustic trial, @not acoustic trial]
		@acoustic trial:;
			SHOW 4, Acoustic trial, J(^J_CompletedAcousticTrials);
			---> S5
		@not acoustic trial:;
			IF (G(^G_TrialsType) = ^I_TrialType_Electrical) OR (L = ^I_TrialType_Electrical) AND (G(^G_TrialsType) = 2) [@electrical trial, @discriminant trial]
				@electrical trial:; 
					SHOW 4, Electrical trial, J(^J_CompletedElectricalTrials);
					---> S9
				@discriminant trial:;
					SHOW 4, Discriminant trial, J(^J_CompletedDiscrimTrials);
					---> S13
\\\</state>

\\\<state id="5" summary="Acoustic trial - Commence tone after inter-trial delay">
S5,
  R#T:;
	SET K(Q + ^K_TrialType) = ^I_TrialType_Acoustic;
	SET K(Q + ^K_ToneFrequency) = G(^G_ToneFrequency);
	ON ^Out_TDSound;
	SHOW 4, Delivering tone, S;
	SET V = G(^G_ToneFrequency);
\	~OnFreq(MG, BOX, V);~; \Removed for sound to be presented by TDT 
	---> S6
\\\</state>
\\\<state id="6" summary="Acoustic trial - Pause until shock delivery, then commence shock">
S6,
  G(^G_ToneShockDelay)#T:;
	IF G(^G_ShocksOn) = ^G_ShocksOn_On [@shocks on, @shocks off]
		@shocks on:;
			SET K(Q + ^K_Shock) = 1;
			Z^ZP_ShockTrigger;
			SHOW 4, Delivering tone and shock, S;
			ON ^Out_ShockEmitter;
			---> S7
		@shocks off:;
			SET K(Q + ^K_Shock) = 0;
			---> S7
\\\</state>
\\\<state id="7" summary="Acoustic trial - Wait shock duration then end shock">
S7,
  G(^G_ShockDuration)#T:;
	OFF ^Out_ShockEmitter;
	OFF ^Out_TDSound;
	ADD J(^J_CompletedAcousticTrials);
	---> S31
\\\</state>

\\\<state id="9" summary="Electrical trial - commence tone after inter-trial delay">
S9,
  R#T:;
	SET K(Q + ^K_TrialType) = ^I_TrialType_Electrical;
	SET K(Q + ^K_ToneFrequency) = G(^G_ToneFrequency);
	ON ^Out_TDStim;
	SHOW 4, Delivering stimulus, S;
	SET V = G(^G_ToneFrequency);
	---> S10
\\\</state>
\\\<state id="10" summary="Electrical Trial - Continue stimulus when should would be occurring">
S10,
  G(^G_ToneShockDelay)#T:;
	IF G(^G_ShocksOn) = ^G_ShocksOn_On [@shocks on, @shocks off]
		@shocks on:;
			SET K(Q + ^K_Shock) = 1;
			Z^ZP_ShockTrigger;
			SHOW 4, Delivering stimulus and shock, S;
			ON ^Out_ShockEmitter;
			---> S11
		@shocks off:;
			SET K(Q + ^K_Shock) = 0;
			---> S11
\\\</state>
\\\<state id="11" summary="Electrical Trial - Wait shock duration then end stimulus">
S11,
  G(^G_ShockDuration)#T:;
	OFF ^Out_ShockEmitter;
	OFF ^Out_TDStim;
	ADD J(^J_CompletedElectricalTrials);
	---> S31
\\\</state>

\\\<state id="13" summary="Discriminant trial - Commence tone after inter-trial delay">
S13,
  R#T:;
	SET K(Q + ^K_Shock) = 0;
	SET K(Q + ^K_TrialType) = ^I_TrialType_DiscrimAcoustic;
	SET K(Q + ^K_ToneFrequency) = G(^G_DiscrimToneFrequency);
	ON ^Out_TDDiscrim;
	SHOW 4, Delivering tone, S;
	SET V = G(^G_DiscrimToneFrequency);
\	~OnFreq(MG, BOX, V);~; \Removed for sound to be presented by TDT 
	---> S14
\\\</state>
\\\<state id="14" summary="Discriminant trial - Wait 'shock delay' duration still playing tone">
S14,
  G(^G_ToneShockDelay)#T:;
	---> S15
\\\</state>
\\\<state id="15" summary="Discriminant trial - Wait 'shock duration' then end">
S15,
  G(^G_ShockDuration)#T:;
	OFF ^Out_TDDiscrim;
	ADD J(^J_CompletedDiscrimTrials);
	---> S31
\\\</state>

\\\<state id="31" summary="Check if full number of trials have been completed, and if so issue terminate command.">
S31,
	#Z^ZP_ExperimentEnd:;
		Z^ZP_TerminateExperiment;
		---> S32
	0":;
		CLEAR 16,16;
		Z^ZP_TrialEnd;
		ADD J(^J_CompletedTrials);
		SET J(^J_MeanITI) = ((S - J(^J_MeanITI)) / J(^J_CompletedTrials)) + J(^J_MeanITI);
		SHOW 2, Completed Trials, J(^J_CompletedTrials);
		SHOW 6, Acoustic Trials, J(^J_CompletedAcousticTrials);
		SHOW 7, Electrical Trials, J(^J_CompletedElectricalTrials);
		SHOW 8, Discriminant Trials, J(^J_CompletedDiscrimTrials);
		SHOW 9, Mean ITI, J(^J_MeanITI);
		IF J(^J_CompletedTrials) >= G(^G_MaxTrials) [@hit max, @less than max]
			@hit max:;
				Z^ZP_TerminateExperiment;
				---> S32
			@less than max:;
				---> S2
\\\</state>
\\\</stateset>

\\\<stateset id="3" summary="Run the countdown display">
S.S.3,
\\\<state id="1" summary="Wait for the start trigger">
S1,
	#START:;
		---> S2
\\\</state>
\\\<state id="2" summary="Wait for countdown commencement">
S2,
	#Z^ZP_TrialStart:;
		SET X = S;
		---> S3
\\\</state>
\\\<state id="3" summary="Run countdown">
S3,
	0.01":;
		SET X = X - (1/1");
		SHOW 5, Next trial in (s), X;
		---> SX
	#Z^ZP_TrialEnd:;
		SHOW 5, Wait..., 0;
		---> S2
\\\</state>
\\\</stateset>

\\\<stateset id="7" summary="Timer - counts up in msec (in steps of 10 msec)">
S.S.7,
\\\<state id="1" summary="Wait for start trigger">
S1,
	#START:;
		---> S2
\\\</state>
\\\<state id="2" summary="Increment counter, hour, minutes, seconds, milliseconds">
S2,
	0.01":;
		SET T = T + 10;
		SET J(^J_CurrentMilliseconds) = J(^J_CurrentMilliseconds) + 10;
		SET U = J(^J_CurrentMilliseconds), W = J(^J_CurrentSeconds);
		~ IF (U = 1000) then begin U := 0; W := W + 1; end; ~;
		SET J(^J_CurrentMilliseconds) = U, U = W, W = J(^J_CurrentMinutes);
		~ IF (U = 60) then begin U := 0; W := W + 1; end; ~;
		SET J(^J_CurrentSeconds) = U, U = W, W = J(^J_CurrentHours);
		~ IF (U = 60) then begin U := 0; W := W + 1; end; ~;
		SET J(^J_CurrentMinutes) = U, J(^J_CurrentHours) = W;
		SHOW 16, Hours, J(^J_CurrentHours);
		SHOW 17, Minutes, J(^J_CurrentMinutes);
		SHOW 18, Seconds, J(^J_CurrentSeconds);
		SHOW 19, Milliseconds, J(^J_CurrentMilliseconds);

			---> SX
	#Z^ZP_TerminateExperiment:;
		---> S32
\\\</state>
\\\</stateset>

\\\<stateset id="20" summary="Camera management - connect to camera system and start/stop video">
S.S.20,
\\\<state id="1" summary="Set constants for video connection state">
S1,
	0":;
		~P := UNCONNECTED;~;
		SET G(^G_CamUnconnectedState) = P;
        ~P := CONNECT_OK;~;
		SET G(^G_CamConnectOkState) = P;
        ~P := CONNECT_FAIL;~;
		SET G(^G_CamConnectFailState) = P;
		---> S2
\\\</state>
\\\<state id="2" summary="Wait for video commands">
S2,
	#Z^ZP_StartVideoRec:;
		~ IF ((box = 1) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX1_CAM1', StartSavingEvent, 'StartEvent'); end; ~;
		~ IF ((box = 1) and (Y = CONNECT_OK)) then begin WriteEventVM('.', 'BOX1_CAM2', StartSavingEvent, 'StartEvent'); end; ~;
		~ IF ((box = 2) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX2', StartSavingEvent, 'StartEvent'); end; ~;
		~ IF ((box = 3) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX3', StartSavingEvent, 'StartEvent'); end; ~;
		~ IF ((box = 4) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX4', StartSavingEvent, 'StartEvent'); end; ~;
		---> SX
	#Z^ZP_EndVideoRec:;
		~ IF ((box = 1) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX1_CAM1', StopSavingEvent, 'StopEvent'); end; ~;
		~ IF ((box = 1) and (Y = CONNECT_OK)) then begin WriteEventVM('.', 'BOX1_CAM2', StopSavingEvent, 'StopEvent'); end; ~;
		~ IF ((box = 2) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX2', StopSavingEvent, 'StopEvent'); end; ~;
		~ IF ((box = 3) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX3', StopSavingEvent, 'StopEvent'); end; ~;
		~ IF ((box = 4) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX4', StopSavingEvent, 'StopEvent'); end; ~;
		---> SX
	#Z^ZP_TerminateExperiment:;
		~ IF ((box = 1) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX1_CAM1', StopSavingEvent, 'StopEvent'); end; ~;
		~ IF ((box = 1) and (Y = CONNECT_OK)) then begin WriteEventVM('.', 'BOX1_CAM2', StopSavingEvent, 'StopEvent'); end; ~;
		~ IF ((box = 2) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX2', StopSavingEvent, 'StopEvent'); end; ~;
		~ IF ((box = 3) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX3', StopSavingEvent, 'StopEvent'); end; ~;
		~ IF ((box = 4) and (P = CONNECT_OK)) then begin WriteEventVM('.', 'BOX4', StopSavingEvent, 'StopEvent'); end; ~;

		~ IF ((box = 1) and (P = CONNECT_OK)) then begin DisconnectVM('.', 'BOX1_CAM1'); P := GetIfaceStatus();end;~;
		~ IF ((box = 1) and (Y = CONNECT_OK)) then begin DisconnectVM('.', 'BOX1_CAM2'); Y := GetIfaceStatus();end;~;
		~ IF ((box = 2) and (P = CONNECT_OK)) then begin DisconnectVM('.', 'BOX2'); P := GetIfaceStatus();end;~;
		~ IF ((box = 3) and (P = CONNECT_OK)) then begin DisconnectVM('.', 'BOX3'); P := GetIfaceStatus();end;~;
		~ IF ((box = 4) and (P = CONNECT_OK)) then begin DisconnectVM('.', 'BOX4'); P := GetIfaceStatus();end;~;
		---> S32
	0.5":;
		~ IF ((box = 1) and (P <> CONNECT_OK)) then begin ConnectToVMEx(MG, BOX, '.', 'BOX1_CAM1'); P := GetIfaceStatus();end;~;
		~ IF ((box = 1) and (Y <> CONNECT_OK)) then begin ConnectToVMEx(MG, BOX, '.', 'BOX1_CAM2'); Y := GetIfaceStatus();end;~;
		~ IF ((box = 2) and (P <> CONNECT_OK)) then begin ConnectToVMEx(MG, BOX, '.', 'BOX2'); P := GetIfaceStatus();end;~;
		~ IF ((box = 3) and (P <> CONNECT_OK)) then begin ConnectToVMEx(MG, BOX, '.', 'BOX3'); P := GetIfaceStatus();end;~;
		~ IF ((box = 4) and (P <> CONNECT_OK)) then begin ConnectToVMEx(MG, BOX, '.', 'BOX4'); P := GetIfaceStatus();end;~;
		IF (P = G(^G_CamUnconnectedState)) [@UNCON, @OTHER]
			 @UNCON: SHOW 26, Video Unconnected,0 ---> SX
             @OTHER: IF (P = G(^G_CamConnectOkState)) [@CONNECTED, @OTHER2]
                @CONNECTED: SHOW 26, Video OK,0 ---> SX
                @OTHER2: IF (P = G(^G_CamConnectFailState)) [@FAIL, @OTHER3]
                   @FAIL:   SHOW 26, Video Failed,0 ---> SX
                   @OTHER3: SHOW 26, Video Unknown,0  ---> SX
\\\</state>
\\\</stateset>



\\\<stateset id="21" summary="Capture ultrasonic A signal times">
S.S.21,
\\\<state id="1" summary="Wait for start signal">
S1,
	#START:;
		---> S2
\\\</state>
\\\<state id="2" summary="Wait for an ultrasonic signal; 2 sequential readings of ultrasonic sound are required - otherwise counted as a 'glitch'">
S2,
	#R^Inp_UltrasonicA:;
		ADD G(^G_USSequentialReadingsA);
		IF G(^G_USSequentialReadingsA) > 1 [@above threshold, @not above threshold]
			@above threshold:;
				SET G(^G_USSequentialReadingsA) = 0;
				SET G(^G_USEventIndexA) = G(^G_UltrasonicIndexOffset);
				SET G(^G_UltrasonicIndexOffset) = G(^G_UltrasonicIndexOffset) + ^H_IndexMultiplier;
				SET H(G(^G_UltrasonicIndexOffset)) = -987.987;
				SET H(G(^G_USEventIndexA) + 0) = J(^J_CurrentHours), H(G(^G_USEventIndexA) + 1) = J(^J_CurrentMinutes), H(G(^G_USEventIndexA) + 2) = J(^J_CurrentSeconds), H(G(^G_USEventIndexA) + 3) = J(^J_CurrentMilliseconds);
				SET H(G(^G_USEventIndexA) + 4) = L;
				SET H(G(^G_USEventIndexA) + 10) = 1;
				---> S3
			@not above threshold:;
				---> SX

	#Z^ZP_TerminateExperiment:;
		---> S32

	0.02":;
		SET G(^G_USSequentialReadingsA) = 0;
		---> S2
\\\</state>
\\\<state id="3" summary="Wait until no ultrasonic signal for 20ms, then reset to 'no-ultrasonic' state">
S3,
	#R^Inp_UltrasonicA:;
		SET H(G(^G_USEventIndexA) + 5) = J(^J_CurrentHours), H(G(^G_USEventIndexA) + 6) = J(^J_CurrentMinutes), H(G(^G_USEventIndexA) + 7) = J(^J_CurrentSeconds), H(G(^G_USEventIndexA) + 8) = J(^J_CurrentMilliseconds);
		SET H(G(^G_USEventIndexA) + 9) = L;
		---> SX

	#Z^ZP_TerminateExperiment:;
		---> S32

	0.02":;
		---> S2
\\\</state>
\\\</stateset>

\\\<stateset id="22" summary="Capture ultrasonic B signal times">
S.S.22,
\\\<state id="1" summary="Wait for start signal">
S1,
	#START:;
		---> S2
\\\</state>
\\\<state id="2" summary="Wait for an ultrasonic signal; 2 sequential readings of ultrasonic sound are required - otherwise counted as a 'glitch'">
S2,
	#R^Inp_UltrasonicA:;
		ADD G(^G_USSequentialReadingsB);
		IF G(^G_USSequentialReadingsB) > 1 [@above threshold, @not above threshold]
			@above threshold:;
				SET G(^G_USSequentialReadingsB) = 0;
				SET G(^G_USEventIndexB) = G(^G_UltrasonicIndexOffset);
				SET G(^G_UltrasonicIndexOffset) = G(^G_UltrasonicIndexOffset) + ^H_IndexMultiplier;
				SET H(G(^G_UltrasonicIndexOffset)) = -987.987;
				SET H(G(^G_USEventIndexB) + 0) = J(^J_CurrentHours), H(G(^G_USEventIndexB) + 1) = J(^J_CurrentMinutes), H(G(^G_USEventIndexB) + 2) = J(^J_CurrentSeconds), H(G(^G_USEventIndexB) + 3) = J(^J_CurrentMilliseconds);
				SET H(G(^G_USEventIndexB) + 4) = L;
				SET H(G(^G_USEventIndexB) + 10) = 2;
				---> S3
			@not above threshold:;
				---> SX

	#Z^ZP_TerminateExperiment:;
		---> S32

	0.02":;
		SET G(^G_USSequentialReadingsB) = 0;
		---> S2
\\\</state>
\\\<state id="3" summary="Wait until no ultrasonic signal for 20ms, then reset to 'no-ultrasonic' state">
S3,
	#R^Inp_UltrasonicA:;
		SET H(G(^G_USEventIndexB) + 5) = J(^J_CurrentHours), H(G(^G_USEventIndexB) + 6) = J(^J_CurrentMinutes), H(G(^G_USEventIndexB) + 7) = J(^J_CurrentSeconds), H(G(^G_USEventIndexB) + 8) = J(^J_CurrentMilliseconds);
		SET H(G(^G_USEventIndexB) + 9) = L;
		---> SX

	#Z^ZP_TerminateExperiment:;
		---> S32

	0.02":;
		---> S2
\\\</state>
\\\</stateset>

\\\<stateset id="23" summary="Signal handler for shock signals">
S.S.23,
\\\<state id="1" summary="Wait for start signal">
S1,
	#START:;
		---> S2
\\\<state id="2" summary="Check for experiment termination">
\\\</state>
S2,
	#Z^ZP_ShockTrigger:;
		ON ^Out_TDShock;
		---> S3

	#Z^ZP_ExperimentEnd:;
		---> S32
\\\</state>
\\\<state id="3" summary="Trigger a ZP_ExperimentEnd every 10ms - this will make sure that everything receives it even">
S3,
	5":;
		OFF ^Out_TDShock;
		---> S2
\\\</state>
\\\</stateset>

\\\<stateset id="25" summary="Experiment timer - check if experiment has reached maximum duration">
S.S.25,
\\\<state id="1" summary="Wait for start trigger">
S1,
	#START:;
		---> S2
\\\<state id="2" summary="Check for experiment termination">
\\\</state>
S2,
	#K^KP_ExperimentEnd:;
		SHOW 4, Manually terminated, 0;
		---> S3
\\\</state>
\\\<state id="3" summary="Trigger a ZP_ExperimentEnd every 10ms - this will make sure that everything receives it even">
S3,
	0.01":;
		Z^ZP_ExperimentEnd;
		---> SX
\\\</state>
\\\</stateset>


\\\</program>
